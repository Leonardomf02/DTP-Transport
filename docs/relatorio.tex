\documentclass[11pt,a4paper]{article}
\usepackage[margin=2cm]{geometry}
\usepackage{times}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{listings}
\usepackage{booktabs}

\setlength{\parskip}{4pt}
\setlength{\parindent}{0pt}
\setstretch{1.0}

\titleformat{\section}{\large\bfseries}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{8pt}{4pt}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}
\titlespacing*{\subsection}{0pt}{6pt}{2pt}

\title{\textbf{DTP — Deadline-aware Transport Protocol}\\
\large Arquiteturas Avançadas de Redes — UBI (2025/26)}
\author{
Leonardo Santos (M15811) \and
Diogo Pedro (E11657) \and
Guilherme Vicente (E11656) \and
Tiago Ramos (E11663)
}
\date{}

\begin{document}
\maketitle
\vspace{-10pt}

\begin{abstract}
\small
O DTP (Deadline-aware Transport Protocol) é um protocolo de transporte para aplicações interativas tempo-real, onde a entrega antes de um deadline é mais importante que a fiabilidade absoluta. Este relatório apresenta a motivação, revisão de literatura, o mini-RFC do protocolo, a implementação completa e resultados experimentais que demonstram melhorias de até 80\% na entrega on-time de pacotes críticos comparado com FIFO tradicional.
\end{abstract}

\section{Introdução}

Aplicações modernas como VR/AR, telemedicina, controlo robótico e streaming interativo exigem requisitos temporais estritos. Protocolos tradicionais (TCP/UDP) não incorporam deadlines explícitas: TCP prioriza fiabilidade sem considerar utilidade temporal dos dados; UDP não oferece mecanismos de priorização ou scheduling.

O DTP aborda este problema ao permitir que aplicações definam deadlines e prioridades para cada pacote, implementando scheduling deadline-aware (EDF), batching adaptativo e controlo de admissão. O protocolo maximiza a fração de pacotes entregues dentro do prazo, descartando dados expirados ou com baixa probabilidade de cumprimento.

\section{Revisão de Literatura}

\textbf{Deadline-aware networking.} Shi et al. (APNet 2019) propõem transportes com deadlines explícitas para datacenters, demonstrando redução de tail latency. Hong et al. (SIGCOMM 2012) introduzem D3 para scheduling deadline-aware em switches.

\textbf{Scheduling tempo-real.} EDF (Earliest Deadline First) é ótimo para single-core scheduling (Liu \& Layland, 1973), mas aplicado ao networking enfrenta desafios de starvation e overhead. Técnicas de aging e batching mitigam estes problemas.

\textbf{QUIC e transporte moderno.} QUIC (RFC 9000) oferece latências baixas e multiplexação de streams, mas não possui mecanismos nativos para deadlines. Stream priorities existem mas não refletem urgência temporal absoluta.

\textbf{AQM e redução de latência.} CoDel (RFC 8289) e FQ-CoDel reduzem bufferbloat ao nível da rede, mas não utilizam informação temporal da aplicação, levando a decisões subótimas de descarte.

\textbf{Gap identificado:} Protocolos existentes carecem de integração entre deadlines da aplicação e decisões de transporte, forçando soluções ad-hoc por aplicação.

\section{Problema Identificado}

\subsection{Limitações das Abordagens Atuais}

\begin{itemize}[noitemsep,topsep=2pt]
    \item \textbf{TCP:} Retransmite e aguarda pacotes que já perderam utilidade temporal, causando head-of-line blocking.
    \item \textbf{UDP:} Não oferece qualquer mecanismo de scheduling, priorização ou feedback de congestão.
    \item \textbf{Soluções de aplicação:} Cada aplicação implementa o seu próprio controlo temporal, duplicando esforços e criando inconsistências.
\end{itemize}

\subsection{Implicações Práticas}

\begin{itemize}[noitemsep,topsep=2pt]
    \item Experiência degradada em VR/AR devido a frames atrasados (motion sickness).
    \item Telemedicina: imagens médicas obsoletas comprometem diagnóstico.
    \item Gaming: input lag superior a 50ms degrada jogabilidade.
    \item Desperdício de largura de banda em dados que chegam tarde demais.
\end{itemize}

\section{Proposta de Protocolo (Mini-RFC)}

\subsection{Objetivo e Arquitetura}

Fornecer um protocolo leve sobre UDP que permita especificar deadlines e prioridades, implementando scheduling EDF com batching para LOW priority, admission control para prevenir DoS, e congestion control AIMD.

\textbf{Entidades:} DTP Client, DTP Server, Scheduler (EDF), Metrics Collector.

\subsection{Formato das Mensagens (24 bytes header)}

\begin{lstlisting}[basicstyle=\scriptsize\ttfamily,frame=single]
 0       1       2       3       4       5       6       7
+-------+-------+-------+-------+-------+-------+-------+-------+
| Magic (0xDEAD)|  Ver  | Type  |  Pri  | Flags |    Sequence   |
+-------+-------+-------+-------+-------+-------+-------+-------+
|                      Timestamp (64 bits)                      |
+-------+-------+-------+-------+-------+-------+-------+-------+
|            Deadline (32 bits)           |    Payload Length   |
+-------+-------+-------+-------+-------+-------+-------+-------+
|   Batch ID    |                    Payload ...                |
+-------+-------+-------+-------+-------+-------+-------+-------+
\end{lstlisting}

\textbf{Campos principais:}
\begin{itemize}[noitemsep,topsep=2pt]
    \item \textbf{Priority (8 bits):} CRITICAL (0), HIGH (1), MEDIUM (2), LOW (3).
    \item \textbf{Timestamp (64 bits):} Tempo de criação (monotonic clock, ms).
    \item \textbf{Deadline (32 bits):} Deadline explícito em ms (default: CRITICAL=500ms, HIGH=1500ms, MEDIUM=3000ms, LOW=6000ms). Permite deadlines customizados por pacote.
    \item \textbf{Flags:} RELIABLE (0x01), DROPPABLE (0x02), BATCHED (0x04).
\end{itemize}

\subsection{Scheduling e Políticas}

\textbf{Scheduler EDF:} Priority heap (min-heap via \texttt{heapq}) com sort key = \texttt{(priority.value, -time\_to\_deadline, enqueue\_order)}. O campo negativo do TTD garante que pacotes mais urgentes são processados primeiro. CRITICAL/HIGH/MEDIUM são dequeued imediatamente. LOW usa batching (batch\_size=10, timeout=50ms) para reduzir overhead de syscalls.

\textbf{Política de expiração:} Pacotes com time\_to\_deadline $\leq$ 0 são descartados no \texttt{dequeue()}, não no \texttt{enqueue()}. Isto permite que pacotes quase expirados ainda tenham hipótese de entrega se a fila estiver curta. CRITICAL nunca é descartado por expiração (deadline=500ms é suficiente em localhost).

\textbf{Queue overflow:} Quando a fila atinge \texttt{max\_size}, o scheduler descarta o pacote de menor prioridade (maior \texttt{priority.value}), preservando pacotes críticos.

\textbf{Admission Control:} Token bucket por prioridade previne starvation e DoS. Os buckets usam refill contínuo baseado em tempo monotónico:
\begin{itemize}[noitemsep,topsep=2pt]
    \item CRITICAL: 50 pkt/s, burst=20 (uso emergencial apenas)
    \item HIGH: 200 pkt/s, burst=50
    \item MEDIUM: 500 pkt/s, burst=100
    \item LOW: 1000 pkt/s, burst=200
\end{itemize}

\textbf{Congestion Control AIMD:} Janela de 1s para cálculo de loss rate. Threshold de 2\% para ativar decrease. Additive increase: +10 pkt/s a cada 10 ACKs. Multiplicative decrease: $\times 0.5$ em congestion, $\times 0.25$ em timeout. Rate mínimo de 50 pkt/s, máximo de 5000 pkt/s. Cooldown de 500ms entre decreases consecutivos.

\section{Implementação e Resultados}

\subsection{Descrição da Implementação}

\textbf{Linguagem:} Python 3.10+ \quad \textbf{Libs:} socket, threading, heapq, dataclasses, struct\\
\textbf{Linhas de código:} $\sim$1500 LOC (excluindo testes)\\
\textbf{Módulos desenvolvidos (8 ficheiros):}
\begin{itemize}[noitemsep,topsep=2pt]
    \item \texttt{protocol.py}: Formato de pacotes, serialização binária (struct pack/unpack), sistema de tempo monotónico via \texttt{time.monotonic()}.
    \item \texttt{scheduler.py}: DTPScheduler (EDF+batching com heapq), SimpleScheduler (FIFO baseline para comparação).
    \item \texttt{metrics.py}: Coletor de estatísticas (latency, on-time rate, percentis p50/p95/p99, jitter).
    \item \texttt{rate\_control.py}: TokenBucket com refill contínuo, AdmissionController per-priority, CongestionController AIMD, Pacer para smooth transmission.
    \item \texttt{client.py}, \texttt{server.py}: Componentes UDP com socket não-bloqueante.
    \item \texttt{logger.py}: Logging estruturado JSONL (um ficheiro por run) para análise posterior.
    \item \texttt{clock\_sync.py}: Sincronização de relógios cliente-servidor (3-way handshake, offset estimation).
\end{itemize}

\subsection{Reprodutibilidade e Ambiente de Teste}

\textbf{Topologia:} Localhost (127.0.0.1), cliente e servidor no mesmo processo.\\
\textbf{Código fonte:} \url{https://github.com/Leonardomf02/DTP-Transport}

\begin{lstlisting}[basicstyle=\scriptsize\ttfamily,frame=single]
# Clonar repositorio e instalar dependencias
git clone https://github.com/Leonardomf02/DTP-Transport.git
cd DTP-Transport/backend
python -m venv venv && source venv/bin/activate
pip install -r requirements.txt

# Executar suite de testes (~8s)
python run_all_tests.py
\end{lstlisting}

\subsection{Parâmetros Experimentais}

\begin{table}[h]
\centering
\small
\begin{tabular}{ll}
\toprule
\textbf{Parâmetro} & \textbf{Valor} \\
\midrule
Runs por cenário & n = 5 \\
Random seed & 42 (fixo para reprodutibilidade) \\
Total pacotes & 200 (5\% CRIT, 15\% HIGH, 30\% MED, 50\% LOW) \\
Payload size & 64 bytes \\
Queue size (Qmax) & 1000 pacotes \\
Batch size (LOW) & 10 pacotes \\
Batch timeout & 50ms \\
Base delay simulado & 5ms × priority\_factor + jitter \\
\bottomrule
\end{tabular}
\caption{Parâmetros experimentais utilizados nos testes.}
\label{tab:params}
\end{table}

\subsection{Resultados Experimentais}

\begin{table}[h]
\centering
\small
\begin{tabular}{lrrr}
\toprule
\textbf{Priority} & \textbf{FIFO} & \textbf{DTP} & \textbf{Melhoria} \\
\midrule
CRITICAL & 20.0\% & 100.0\% & +80.0\% \\
HIGH     & 40.0\% & 100.0\% & +60.0\% \\
MEDIUM   & 65.0\% & 100.0\% & +35.0\% \\
LOW      & 100.0\% & 100.0\% & 0.0\% \\
\bottomrule
\end{tabular}
\caption{Comparação FIFO vs DTP — On-Time Delivery Rate (seed=42, n=200 pacotes).}
\label{tab:ontime}
\end{table}

\subsection{Análise dos Resultados}

Os resultados da Tabela~\ref{tab:ontime} demonstram que o DTP consegue 100\% on-time delivery para todas as prioridades, enquanto FIFO falha significativamente: apenas 20\% para CRITICAL, 40\% para HIGH e 65\% para MEDIUM.

\textbf{Porque FIFO falha:} Em FIFO, pacotes LOW (50\% do tráfego) com deadlines longas (6000ms) entram primeiro na fila e atrasam pacotes CRITICAL que chegam depois. Com 200 pacotes e delays de processamento de 5-25ms cada, um pacote CRITICAL pode esperar 150+ pacotes × 20ms $\approx$ 3000ms, excedendo largamente o seu deadline de 500ms.

\textbf{Porque DTP funciona:} O scheduler EDF reordena a fila continuamente. Um pacote CRITICAL sempre tem sort\_key menor (priority=0) que qualquer outro, sendo processado imediatamente independentemente da ordem de chegada.

\textbf{Trade-off LOW priority:} LOW mantém 100\% em ambos porque tem deadline generoso (6000ms). Em DTP, pacotes LOW são deliberadamente atrasados para priorizar tráfego urgente, mas ainda cumprem o deadline.

\textbf{Validações adicionais:}
\begin{itemize}[noitemsep,topsep=2pt]
    \item \textbf{Reprodutibilidade:} seed=42 garante resultados idênticos em cada execução.
    \item \textbf{Priority Ordering:} Validado que CRITICAL é sempre processado primeiro.
    \item \textbf{Batching:} Confirmado que batches LOW contêm até 10 pacotes ou são flushed após 50ms timeout.
\end{itemize}

\subsection{Limitações}

\begin{itemize}[noitemsep,topsep=2pt]
    \item \textbf{User-land only:} Solução não mexe em routers/switches; benefícios limitados a endpoints.
    \item \textbf{Sem integração QUIC/HTTP3:} Implementação standalone sobre UDP raw.
    \item \textbf{FEC não ativado:} Forward Error Correction planeado mas não implementado.
    \item \textbf{Testes localhost:} Resultados em rede real podem variar.
\end{itemize}

\section{Conclusões e Trabalho Futuro}

O DTP demonstra que a integração de deadlines no transporte melhora significativamente a performance de aplicações tempo-real, com melhorias de até 80\% na entrega on-time de pacotes críticos. A implementação valida a viabilidade do protocolo e confirma que EDF com batching adaptativo é eficaz.

\textbf{Trabalho futuro:} FEC adaptativo, multi-path (MPTCP-like), integração com QUIC, suporte em switches (P4), e predição de congestion com ML.

\section*{Referências}
\small
\begin{itemize}[leftmargin=10pt,noitemsep,topsep=2pt]
    \item Shi, Y., et al. (2019). \textit{Deadline-Aware Transport in Datacenters}. APNet.
    \item Hong, C. Y., et al. (2012). \textit{Finishing Flows Quickly with Preemptive Scheduling}. SIGCOMM.
    \item Liu, C. L., \& Layland, J. W. (1973). \textit{Scheduling Algorithms for Multiprogramming}. JACM.
    \item RFC 9000 — QUIC: A UDP-Based Multiplexed and Secure Transport.
    \item RFC 8289 — Controlled Delay Active Queue Management.
\end{itemize}

\end{document}
